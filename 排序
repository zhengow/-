1. 冒泡排序：两层循环，第一层循环决定第i大元素，第二层循环是为了从头开始每个元素与下一个元素比较，将大元素后移。
时间复杂度：O（n2） 空间复杂度O（1） 稳定
void bubblesort(int a[], int n){
	for(int i=0;i<n;i++){
		for(int j=0;j<n-i-1;j++){
			if(a[j]>a[j+1]){
				int tmp=a[j];
				a[j]=a[j+1];
				a[j+1]=tmp;
			}
		}
	}
}

2.选择排序：两层循环，每次选出最大放在数组最后。
时间复杂度：O（n2） 空间复杂度O（1） 不稳定：在交换过程中出现，可能把同样大小的数字从后面换到前面去了
void selectsort(int a[], int n){
	for(int i=0;i<n;i++){
		int max=a[i];
		int count=i;
		int j=i+1;
		for(;j<n-i;j++){
			if(a[j]>max){
				count=j;
				max=a[j];
			}
		}
		a[count]=a[j-1];
		a[j-1]=max;
	}
}

3. 插入排序
时间复杂度：O（n2） 空间复杂度O（1） 稳定
void insertsort(int a[], int n){
	for(int i=1;i<n;i++){
		int tmp=a[i];
		int j=i-1;
		for(;j>=0;j--){
			if(a[j]>tmp)
				a[j+1]=a[j];
			else
				break;
		}
		a[j+1]=tmp;
	}
}

4.希尔排序：以一定增量划分子序列，然后用插入排序
时间复杂度：O（n2） 空间复杂度O（1） 不稳定：在子序列中稳定，但是可能会在子序列排序中把一样大的元素放在了左边
void shellsort(int a[], int n){
	int incre=n;
	
	while(incre>1){
		incre/=2;
		for(int i=0;i<incre;i++){ //设置初始位置 
			for(int j=i+incre;j<n;j+=incre){
				int k=j-incre;
				int tmp=a[j];
				for(;k>=i;k-=incre){
					if(a[k]>tmp)
						a[k+incre]=a[k];
					else
						break;
				}
				a[k+incre]=tmp;
			}
		}
	}
}

5. 快速排序：选择一个支点，比它小的放左边，比它大的放右边，递归。放置方法为挖坑填数
时间复杂度：O（nlogn） 空间复杂度O（1） 不稳定：将支点一边的数放在支点的一边上会出现不稳定情况
void quicksort(int a[], int l, int r){
	if(r-l<=1)
		return;
	int i=l,j=r-1,pivot=a[l];
	while(i!=j){
		for(;j>i;j--){
			if(a[j]<pivot){
				a[i++]=a[j];
				break;
			}
		}
		for(;i<j;i++){
			if(a[i]>pivot){
				a[j--]=a[i];
				break;
			}
		}
	}
	a[i]=pivot;
	quicksort(a,l,i);
	quicksort(a,i+1,r);
}

6.归并排序：将有序数组合并，若数组不有序则继续对半划分，直至划分至一个数字则认为有序。
时间复杂度：O（nlogn） 空间复杂度O（n） 稳定
